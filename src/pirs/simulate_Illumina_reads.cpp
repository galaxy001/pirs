#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <math.h>
#include <map>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "gzstream.h"
#include "simulate.h"
#include "load_file.h"
#include "global.h"

using namespace std;

//parameter variable
PARAMETER InputParameter ={100,500,-1,1,0,1,1,1,64,1,5,-1,"","","","","","Illumina"};

int Ref_Base_num = 0;  //ATCG: 4
int Statistical_Cycle_num = 0; //the cycle number in Base-calling profile
int Seq_Base_num = 0;  //ATCG: 4
int Quality_num = 0;  //the quality score number in Base-calling profile
int Simulate_Cycle_num = 0; //the cycle number of simulation
double Statistical_average_error_rate = 0; //the average error rate in Base-calling profile

int Statistical_Cycle_num2 = 0; //the cycle number in InDel-error profile
double** InDel_error_matrix = NULL; //for simulating InDel-error in reads
int* InDel_num = NULL; //for getting indel number
int InDel_max_len = 0;
uint64_t Read1_ins_sum = 0;
uint64_t Read1_del_sum = 0;
uint64_t Read2_ins_sum = 0;
uint64_t Read2_del_sum = 0;

ogzstream Gz_outfile1; 
ogzstream Gz_outfile2;
ofstream Outfile1;
ofstream Outfile2;

ogzstream Infor_outfile;

double*** First_cycle_matrix = NULL;  //for calling base and Qtran simulation, get the first cycle matrix
double*** Simulation_matrix2 = NULL;
double**** Simulation_matrix1 = NULL;  //for calling base and quality simulation
double*** Simulation_matrix = NULL; //for simulating fasta file
double* GC_bias_abundance = NULL;  //for simulation GC bias 
map<int,uint64_t> InsertSize_distr; //record the insert size distribution 
uint64_t* Error_pos_distr = NULL; //record the error position distribution
double* Q_to_Erate_distr = NULL; //record quality score to error rate distribution
uint64_t Total_read_pair = 0; 

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2);
//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequ,string &sequ2,uint64_t read_genome);
//simulate fastq reads
//uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, uint64_t reads_all);
uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all);
//simulate fasta reads
uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all);


void SimReads_Usage(){
	cout<<"\nDescription:"<<endl;
	cout<<"   It is a program for simulating Illumina pair-end reads, with a series of characters generate by illumina ";
	cout<<"sequencer, such as insertsize distribution, sequencing error(substitution, insertion, deletion), quality score and GC bias. ";
	cout<<"User should set the mean value and the standard deviation of the normal distribution for simulating insertsize ";
	cout<<"distribution, usually we set the insertsize_sd as 1/20 of the insertsize_mean. The normal distribution ";
	cout<<"function model we used in this program is simulated by Box-muller method. ";
	cout<<"This program simulates Illumina sequencing error, quality score and GC bias according to the empirical distribution profile. ";
	cout<<"User can set the path of profile or using the default file in this program package, which is generated by large real sequencing data. ";
	cout<<"It need two reference genome sequence if you want to simulate reads of diploid(heterozygosis SNP, heterozygosis Indel and structural variation), ";
	cout<<"you can get another diploid genome sequence by the command \"pirs diploid\", but remember that heterozygosis SNP rate and heterozygosis Indel rate only exist in diploid. \n";
	cout<<endl<<"Program: pirs simulate"<<endl;
	cout<<endl<<"Usage:\t./pirs simulate [options]"<<endl;
	cout<<"\t-i  <string>  input_ref1,input reference genome sequence *.fa/*.fa.gz, no default vaule"<<endl;
	cout<<"\t-I  <string>  input_ref2,for diploid genome, input another reference genome sequence which was generated by command \"pirs diploid\""<<endl;
	cout<<"\t-s  <string>  Base-calling profile,input Base-calling profile for simulating sequencing error and quality score,default: (exe_path)"<<BASE_CALLING_PROFILE<<endl;
	cout<<"\t-d  <string>  GC content-coverage profile,input GC content-coverage file for simulating GC bias, the default profile are determined based on the twice of read length"<<endl;
	cout<<"\t-b  <string>  InDel-error profile,input InDel-error profile for simulating InDel-error of reads, default:(exe_path)"<<INDEL_ERROR_PROFILE<<endl;
	cout<<"\t-l  <int>     read_len,set length of read,read1 and read2 have the same length,default:"<<InputParameter.Read_length<<endl;
	cout<<"\t-x  <double>  coverage,set the sequencing coverage(sometimes called depth),default:"<<InputParameter.Coverage<<endl;
	cout<<"\t-m  <int>     insertsize_mean,set the average value of insert size,default:"<<InputParameter.Insertsize_mean<<endl;
	cout<<"\t-v  <int>     insertsize_sd,set the standard deviation of insert sizes, default:insertsize_mean/20"<<endl;
//	cout<<"\t-e  <double>  error_rate,set the average error rate over all cycles,default=average error rate of Base-calling profile"<<endl;
	cout<<"\t-a  <int>     simulate reads indel, 0:no, 1:yes. default:"<< InputParameter.Is_simulate_InDel<<endl;
	cout<<"\t-g  <int>     simulate GC bias, 0:no, 1:yes, default:"<<InputParameter.Is_simulate_GC_bias<<endl;
	cout<<"\t-q  <int>     simulate quality value, 0:no(fasta), 1:yes(fastq), default:"<<InputParameter.Is_simulate_quality<<endl;
	cout<<"\t-M  <int>     simulate quality value by Quality-transition mode, 0:no, 1:yes, default:"<<InputParameter.Q_Mode<<endl;
	cout<<"\t-Q  <int>     ASCII shift of quality value, generally 64 or 33 for Illumina data, default:"<<InputParameter.Q_shift<<endl;
	cout<<"\t-f  <int>     cyclize insert fragment (influence on PE reads' direction) 0: read1-forward read2-reverse, 1: read1-reverse read2-forward, default:"<<InputParameter.Is_cyclization<<endl;
	cout<<"\t-c  <int>     output file type, 0:text, 1:compressed(*.gz), default:"<<InputParameter.Output_type<<endl;
	cout<<"\t-o  <string>  prefix of output file, default:"<<InputParameter.Output_prefix<<endl;
	cout<<"\t-h            output help infomation."<<endl;
	cout<<endl<<"Example:"<<endl;
	cout<<"\t1. ./pirs simulate -i ref_sequence.fa"<<endl;
	cout<<"\t  Every parameter use the default value."<<endl;
	cout<<"\t2. ./pirs simulate -i ref_sequence.fa -l 100 -x 20 -o human_500_100"<<endl;
	cout<<"\t  Just set read length and coverage you needed."<<endl;
	cout<<"\t3. ./pirs simulate -i ref_sequence.fa -o human -m 600 -v 30"<<endl;
	cout<<"\t  Set insertsize distribution."<<endl;
	cout<<"\t4. ./pirs simulate -i ref_sequence.fa -I ref_seq.snp.indel.invertion.fa.gz -o human "<<endl;
	cout<<"\t  The genome is diploid and you want to produce heterozygosis SNPs  heterozygosis Indels in reads, "<<endl;
	cout<<"\t  the -I input file was generated by command \"pirs diploid\"."<<endl;
	cout<<"\t5. ./pirs simulate -i ref_sequence.fa -g 0 -m 2000 -f 1 -c 0 -o human "<<endl;
	cout<<"\t  simulate no GCbias, cyclize the large insert-size library, output file is text format."<<endl;
	cout<<"\t6. ./pirs simulate -i ref_sequence.fa -q 0 -o human "<<endl;
	cout<<"\t  simulate fasta file, the ouput is in *.fa format."<<endl;
	cout<<"\t7. ./pirs simulate -i ref_sequence.fa -a 0 -l 75 -o human "<<endl;
	cout<<"\t  simulate no InDel-error."<<endl;
	exit(-1);
}

void SimReads_Getopt(int argc,char *argv[]){
	int c;
	while ((c=getopt(argc,argv,"i:I:s:d:b:l:x:m:v:a:f:g:q:M:Q:c:o:h"))!=-1)
	{
		switch(c){
			case 'i': InputParameter.Input_ref1=optarg;break;
			case 'I': InputParameter.Input_ref2=optarg;break;
			case 's': InputParameter.BaseCalling_profile=optarg;break;
			case 'd': InputParameter.GC_depth_profile=optarg;break;
			case 'b': InputParameter.InDel_error_profile=optarg;break;
			case 'l': InputParameter.Read_length=atoi(optarg);break;
			case 'x': InputParameter.Coverage=atof(optarg);break;
			case 'm': InputParameter.Insertsize_mean=atoi(optarg);break;
			case 'v': InputParameter.Insertsize_sd=atoi(optarg);break;
			case 'a': InputParameter.Is_simulate_InDel=atoi(optarg);break;
			case 'f': InputParameter.Is_cyclization=atoi(optarg);break;
			case 'g': InputParameter.Is_simulate_GC_bias=atoi(optarg);break;
			case 'q': InputParameter.Is_simulate_quality=atoi(optarg);break;
			case 'M': InputParameter.Q_Mode=atoi(optarg);break;
			case 'Q': InputParameter.Q_shift=atoi(optarg);break;
			case 'c': InputParameter.Output_type=atoi(optarg);break;
			case 'o': InputParameter.Output_prefix=optarg;break;
			case 'h': SimReads_Usage();break;
			default: SimReads_Usage();
		}
	}
}

int simulate_Illumina_reads(int argc, char *argv[])
{
	time_t time_start, time_end;
	time_start = time(NULL);
	srand((unsigned)time(NULL));
	
	if (argc==1)
	{
		SimReads_Usage();
	}
	
	SimReads_Getopt(argc,argv);
	
	argv--;
	
	//set insertsize sd default value
	if(InputParameter.Insertsize_sd == -1){InputParameter.Insertsize_sd = int(InputParameter.Insertsize_mean/20);}
	//check parameter
	if(InputParameter.Input_ref1 == ""){cerr<<"Error: there is not default value with option -i, please input reference sequence!"<<endl;exit(-1);}
	if(InputParameter.Read_length <= 0){cerr<<"Error: read length should be set bigger than 0, please check option -l !"<<endl;exit(-1);}
	if(InputParameter.Coverage <= 0){cerr<<"Error: coverage should be set bigger than 0, please check option -x !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_mean < InputParameter.Read_length){cerr<<"Error: insertize mean should be set bigger than read_length, please check option -m !"<<endl;exit(-1);}
	if(InputParameter.Insertsize_sd < 0){cerr<<"Error: insertsize_sd should be set bigger than 0, please check option -v !"<<endl;exit(-1);}
	if(InputParameter.Error_rate != -1 && InputParameter.Error_rate < 0 || InputParameter.Error_rate >= 1){cerr<<"Error: error_rate should be set between 0 and 1, or set -1 to simulate default error rate according with error profile, please check option -e !"<<endl;exit(-1);}
	if(InputParameter.Is_cyclization != 0 && InputParameter.Is_cyclization != 1){cerr<<"Error: Is_cyclization should be set 0 or 1, please check option -f !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_GC_bias != 0 && InputParameter.Is_simulate_GC_bias != 1){cerr<<"Error: Is_simulate_GC_bias should be set 0 or 1, please check option -g !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_quality != 0 && InputParameter.Is_simulate_quality != 1){cerr<<"Error: Is_simulate_quality should be set 0 or 1, please check option -q !"<<endl;exit(-1);}
	if(InputParameter.Is_simulate_InDel != 0 && InputParameter.Is_simulate_InDel != 1){cerr<<"Error: Is_simulate_InDel should be set 0 or 1, please check option -a !"<<endl;exit(-1);}
	if(InputParameter.Q_Mode != 0 && InputParameter.Q_Mode != 1){cerr<<"Error: Q_Mode should be set 0 or 1, please check option -M !"<<endl;exit(-1);}
	if(InputParameter.Output_type != 0 && InputParameter.Output_type != 1){cerr<<"Error: output_type should be set 0 or 1, please check option -c !"<<endl;exit(-1);}

	//set the simulate cycle number
	Simulate_Cycle_num = InputParameter.Read_length*2;
	//initialize error position distribution table
	Error_pos_distr = new uint64_t[Simulate_Cycle_num+1];
	Q_to_Erate_distr = new double[Simulate_Cycle_num+1];
	for(int i=0; i<=Simulate_Cycle_num; i++)
	{
		Error_pos_distr[i] = 0;
		Q_to_Erate_distr[i] = 0.0;
	}
	
	//input file
	igzstream infile; 
	igzstream infile2;
	//output file
	ofstream insert_log;
	ofstream error_log;
	//check and open file
	set_and_check_file( InputParameter, infile, infile2, Outfile1,	Outfile2, Gz_outfile1, Gz_outfile2, insert_log, error_log, Infor_outfile);
	
	
	////////////////////Load error profile///////////////////////
	
	string exe_path = argv[0]; //program package path
	
	cerr<<"Start to preview error profile..."<<endl;
	//get dimensions of error profile  
	preview_BaseCalling_profile (InputParameter, exe_path, Ref_Base_num, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate);
  cerr << "Dimensions of Base-calling profile:\n";
  cerr << "       Ref_Base_num: " << Ref_Base_num << endl;
  cerr << "       Statistical_Cycle_num: " << Statistical_Cycle_num << endl;
  cerr << "       Seq_Base_num: " << Seq_Base_num << endl;
  cerr << "       Quality_num: " << Quality_num << endl;
  cerr <<	"       "<<InputParameter.Read_length<<"bp reads total average substitution error rate: "<< Statistical_average_error_rate <<endl;
	
	
	//initialize simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){ 
  	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
  	First_cycle_matrix = new double**[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		First_cycle_matrix[i] = new double*[2];
  		for(int j=0; j<2; j++)
  		{
  			First_cycle_matrix[i][j] = new double[Seq_Base_num*Quality_num];
  			for(int k=0; k<Seq_Base_num*Quality_num; k++)
  			{
  				First_cycle_matrix[i][j][k] = 0;
  			}
  		}
  	}

  	Simulation_matrix1 = new double***[Ref_Base_num];
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		Simulation_matrix1[i] = new double**[Simulate_Cycle_num];
  		for(int j=0; j<Simulate_Cycle_num; j++)
  		{
  			Simulation_matrix1[i][j] = new double*[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix1[i][j][k] = new double[Seq_Base_num];
  				for(int l=0; l<Seq_Base_num; l++)
  				{
  					Simulation_matrix1[i][j][k][l] = 0;
  				}
  			}
  		}
  	}
  	
		Simulation_matrix2 = new double**[Simulate_Cycle_num];
		for(int i=0; i<Simulate_Cycle_num; i++)
		{
			Simulation_matrix2[i] = new double*[Quality_num];
			for(int j=0; j<Quality_num; j++)
			{
  			Simulation_matrix2[i][j] = new double[Quality_num];
  			for(int k=0; k<Quality_num; k++)
  			{
  				Simulation_matrix2[i][j][k] = 0;
  			}
			}
		}
  }else{ 
  	if(InputParameter.Is_simulate_quality){
    	//simulate fq read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num*Quality_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num*Quality_num];
    			for(int k=0; k<Seq_Base_num*Quality_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}else{
    	//simulate fa read matrix
    	//initialize matrix table  Ref_Base_num*Simulate_Cycle_num*Seq_Base_num
    	Simulation_matrix = new double**[Ref_Base_num];
    	for(int i=0; i<Ref_Base_num; i++)
    	{
    		Simulation_matrix[i] = new double*[Simulate_Cycle_num];
    		for(int j=0; j<Simulate_Cycle_num; j++)
    		{
    			Simulation_matrix[i][j] = new double[Seq_Base_num];
    			for(int k=0; k<Seq_Base_num; k++)
    			{
    				Simulation_matrix[i][j][k] = 0;
    			}
    		}
    	}
  	}
  }
	
	string base_calling_profile = "none";
	//get the simulation matrix
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix1, First_cycle_matrix);
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Ref_Base_num, Simulate_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix2);
	}else{
		base_calling_profile = load_BaseCalling_profile(InputParameter, exe_path, Statistical_Cycle_num, Seq_Base_num, Quality_num, Statistical_average_error_rate, Simulation_matrix);
	}
	///////////////////////////load GC bias profile///////////////////////////////
	
	//get GC abundance for simulate GC bias
	string gc_bias_profile = "none";
	if(InputParameter.Is_simulate_GC_bias){
		GC_bias_abundance = new double[101];
		for(int i = 0; i <= 100; i++)
		{
			GC_bias_abundance[i] = 0.0;
		}
		gc_bias_profile = load_GC_depth_profile (InputParameter, exe_path, GC_bias_abundance);
	}
	
	////////////////////////////load InDel-error profile///////////////////////////

	string indel_error_profile = "none";
	if(InputParameter.Is_simulate_InDel)
	{
		uint64_t Read1_count = 0;
		uint64_t Read2_count = 0;
		preview_InDel_error_profile (InputParameter, exe_path, Statistical_Cycle_num2, InDel_max_len, Read1_count, Read2_count);
		if(Statistical_Cycle_num2 == 0 || InDel_max_len == 0)
		{
			cerr<<"Warning: can not get the InDel-error profile information, so program not to simualte InDel-error, please check profile is in the right format!"<<endl;
			InputParameter.Is_simulate_InDel = 0;
		}else{
			InDel_error_matrix =  new double*[Statistical_Cycle_num2];
			for(int i = 0; i < Statistical_Cycle_num2; i++)
			{
				InDel_error_matrix[i] = new double[InDel_max_len*2+1];  // -3 -2 -1 0 1 2 3
				for(int j = 0; j < InDel_max_len*2+1; j++)
				{
					InDel_error_matrix[i][j] = 0;
				}
			}
			InDel_num = new int[InDel_max_len*2+1];
			for(int i =0; i < InDel_max_len*2+1; i++)
			{
				InDel_num[i] =  InDel_max_len +  (i - InDel_max_len*2); //0(-3) 1(-2) 2(-1) 3(0) 4(1) 5(2) 6(3)
			}
			indel_error_profile = load_InDel_error_profile(InputParameter, exe_path, Statistical_Cycle_num2, InDel_max_len, Read1_count, Read2_count, InDel_num, InDel_error_matrix);
		}
	}
	
	//////////////////////////output input parameter information///////////////////

	string ref2_info = InputParameter.Input_ref2;
	if(InputParameter.Input_ref2.empty())
	{
		ref2_info = "none, just simulate reads from haploid." ;
	}
	string Is_cyc = "yes";
	if(InputParameter.Is_cyclization == 0)
	{
		Is_cyc = "no";
	}
	string Is_simGC = "yes";
	if(InputParameter.Is_simulate_GC_bias == 0)
	{
		Is_simGC = "no";
	}
	string Is_Indel = "yes";
	if(InputParameter.Is_simulate_InDel == 0)
	{
		Is_Indel = "no";
	}
	string Is_simQual = "no";
	if(InputParameter.Is_simulate_quality)
	{
		Is_simQual = "yes";
	}
	string Is_qt = "yes";
	if(InputParameter.Q_Mode == 0)
	{
		Is_qt = "no";
	}
	string outtype = "compressed(*.gz)";
	if(InputParameter.Output_type == 0)
	{
		outtype = "text";
	}
	
	Infor_outfile<<"#input reference1: "<<InputParameter.Input_ref1<<endl
		<<"#input reference2: "<<ref2_info<<endl
		<<"#base-Calling profile: "<<base_calling_profile<<endl
		<<"#simulate GC content-coverage bias: "<<Is_simGC<<endl
		<<"#GC content-coverage profile: "<<gc_bias_profile<<endl
		<<"#simulate InDel-error in reads: "<<Is_Indel<<endl
		<<"#InDel-error profile: "<<indel_error_profile<<endl
		<<"#read length: "<<InputParameter.Read_length<<endl
		<<"#data coverage: "<<InputParameter.Coverage<<endl
		<<"#mean of insertsize: "<<InputParameter.Insertsize_mean<<endl
		<<"#standard deviation of insert sizes: "<<InputParameter.Insertsize_sd<<endl
		<<"#cyclization: "<<Is_cyc<<endl
		<<"#reads file output type: "<<outtype<<endl
		<<"#output prefix: "<<InputParameter.Output_prefix<<endl
		<<"#simulate quality value: "<<Is_simQual<<endl;
		
	if(InputParameter.Is_simulate_quality == 1)
	{
		Infor_outfile<<"#simulate quality value by Quality-transition mode: "<< Is_qt<<endl
			<<"#ASCII shift of quality value: "<<InputParameter.Q_shift<<endl;
	}
	Infor_outfile<<endl<<"#read_id\tinsert_size\t-i/-I\tchr\t+/-\tposition\t substitution\tinsertion\tdeletion"<<endl;
	
	
	///////////////////////////get genome seq and start to simulate reads/////////////////////////////
	
	//start simulation
	Get_genome(infile,infile2);
	
	
	/////////////////////////output error distribution and insert size distribution////////////////////////////

	//ouput error position distribution
	error_log<<"**********Error rate distribution**********"<<endl;
	if(InputParameter.Is_simulate_quality){
		error_log<<"Cycle\tReal_error_rate\tQuality_to_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<"\t"<<Q_to_Erate_distr[i]/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}else{
		error_log<<"Cycle\tReal_error_rate"<<endl;
  	for(int i=1; i<=Simulate_Cycle_num; i++){
  		error_log<<i<<"\t"<<double(Error_pos_distr[i])/double(Total_read_pair)<<endl;
  		if(i== InputParameter.Read_length){error_log<<endl;}
  	}
	}
	delete[] Error_pos_distr;
	delete[] Q_to_Erate_distr;
	
	//output insert size distribution
	insert_log<<"**********Insert size distribution************"<<endl
		<<"insert_size_len"<<"\t"<<"number"<<endl;
	map<int, uint64_t>::const_iterator map_it = InsertSize_distr.begin();
	while (map_it != InsertSize_distr.end())
	{
		insert_log<<map_it->first<<"\t"<<map_it->second<<endl;
		//cout<<map_it->second<<endl;
		map_it++;
	}
	
	if(InputParameter.Is_simulate_GC_bias)
	{
		delete[] GC_bias_abundance;
	}
	
	if(InputParameter.Is_simulate_quality && InputParameter.Q_Mode == 1){
    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		for(int k=0; k<Quality_num; k++)
    		{
    			delete[] Simulation_matrix1[i][j][k];
    		}
    		delete[] Simulation_matrix1[i][j];
    	}
    	delete[] Simulation_matrix1[i];
    }
    delete[] Simulation_matrix1;
    

  	for(int j=0; j<Simulate_Cycle_num; j++)
  	{
  		for(int k=0; k<Quality_num; k++)
  		{
  			delete[] Simulation_matrix2[j][k];
  		}
  		delete[] Simulation_matrix2[j];
  	}
  	delete[] Simulation_matrix2;
  	
  	for(int i=0; i<Ref_Base_num; i++)
  	{
  		for(int j=0; j<2; j++)
  		{
  			delete[] First_cycle_matrix[i][j];
  		}
  		delete[] First_cycle_matrix[i];
  	}
  	delete[] First_cycle_matrix;
  	
	}else{

    for(int i=0; i<Ref_Base_num; i++)
    {
    	for(int j=0; j<Simulate_Cycle_num; j++)
    	{
    		delete[] Simulation_matrix[i][j];
    	}
    	delete[] Simulation_matrix[i];
    }
    delete[] Simulation_matrix;
	}
	
	if(InputParameter.Is_simulate_InDel)
	{
		for(int i = 0; i < Statistical_Cycle_num2; i++)
		{
			delete[] InDel_error_matrix[i];
		}
		delete[] InDel_error_matrix;
		
		delete[] InDel_num;
	}

	infile.close();
	if(InputParameter.Input_ref2 != ""){infile2.close();}
	insert_log.close();
	error_log.close();
	if(InputParameter.Output_type == 1){
		Gz_outfile1.close();
		Gz_outfile2.close();
	}else{
		Outfile1.close();
		Outfile2.close();
	}
	
	Infor_outfile.close();
	
  cerr<<"Read1 insertion sum: "<<Read1_ins_sum<<endl;
  cerr<<"Read1 deletion sum: "<<Read1_del_sum<<endl;
  cerr<<"Read2 insertion sum: "<<Read2_ins_sum<<endl;
  cerr<<"Read2 deletion sum: "<<Read2_del_sum<<endl;
	
	time_end = time(NULL);
	cerr<<"All done! Run time: "<<time_end-time_start<<"s."<<endl;
	
	return 0;
}

//get genome sequence and start to simulate read 
void Get_genome(igzstream &inf,igzstream &inf2){
	string line,line2,id,id_line,seq,seq2;
	uint64_t readINgenome=0;

	while (getline(inf,line,'\n'))
	{
		if (line[0]=='>')
		{
			if (seq!="")
			{	
				//another diploid seq
				if(InputParameter.Input_ref2 != ""){
					while(getline(inf2,line2,'\n'))
					{
						if(line2[0] == '>')
						{
							if(seq2!="")
							{
								//cerr <<seq2<<endl;
        				cerr<<"Have finished reading scaffold "<<id<<endl;
        				readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
        				seq="";
        				seq2="";
        				break;
							}
						}else{
							seq2+=line2;
						}
					}
				}else{
					cerr<<"Have finished reading scaffold "<<id<<endl;

					readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
					seq="";
				}
			}
			id_line = line;
			line.erase(0,1);
			int pos=line.find(" ");
			line=line.substr(0,pos);
			id=line;
		}else{
			seq+=line;
		}		
	}
	cerr<<"Have finished reading scaffold "<<id<<endl;
	if(InputParameter.Input_ref2 != ""){
		while(getline(inf2,line2,'\n'))
		{
			if(line2[0] == '>'){continue;}
			seq2+=line2;
		}
		//cerr<<seq2<<endl;
	}
	readINgenome+=contral_reads_quantity(id_line,id,seq,seq2,readINgenome);
}

//contral the quantity of simulate reads for each chromosome one by one
uint64_t contral_reads_quantity(string id_line,string id,string &sequence,string &sequence2,uint64_t read_genome)
{
	uint64_t readonchr=0;
	if (sequence.size()<InputParameter.Insertsize_mean)
	{
		return 0;
	}
	//convert lower case to upper case 
	to_upper(sequence);

	uint64_t sequence_length=sequence.size();
	uint64_t reads_pair_num=0;
	
	if (InputParameter.Input_ref2 != "")
	{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);
	}else{
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	}
	Total_read_pair = Total_read_pair + (uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2);
	
//	string id_1 = id+" 1";
	if(InputParameter.Is_simulate_quality){		
		readonchr=simulate_fq_reads(sequence,sequence_length,reads_pair_num,
			id, 1,read_genome);
	}else{
		readonchr=simulate_fa_reads(sequence,sequence_length,reads_pair_num, id, 1, read_genome);
	}
	
	//simulate reads of another diploid genome 
	if (InputParameter.Input_ref2 != "") 
	{
		sequence_length=sequence2.size();
		if (sequence_length<InputParameter.Insertsize_mean)
		{
			return 0;
		}
		reads_pair_num=(uint64_t)(sequence_length*InputParameter.Coverage/InputParameter.Read_length/2/2);

		uint64_t readonchr2=read_genome+readonchr;
//		string id_2 = id+" 2";
		if(InputParameter.Is_simulate_quality){
			readonchr+=simulate_fq_reads(sequence2,sequence_length,reads_pair_num,
				id, 2, readonchr2);
		}else{
			readonchr+=simulate_fa_reads(sequence2,sequence_length,reads_pair_num, id, 2, readonchr2);
		}
	}
	return readonchr;
}


uint64_t simulate_fq_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);

		map<int,string,less<int> > indel1;
		map<int,string,less<int> > indel2;
		int r1_slen = 0;
		int r2_slen = 0; 
		if(InputParameter.Is_simulate_InDel)
		{
			get_reads_indel(InputParameter.Read_length, indel1, indel2, r1_slen, r2_slen, InDel_max_len, InDel_error_matrix, InDel_num);
		}
		
		string ref_read1, ref_read2;
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly and deciding read +/-
		
		int read1_pos, read2_pos;
		if(selection == 0)
		{
			ref_read1 = sub_str.substr(0, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
			read1_pos = pos+1;
			read2_pos = pos+insertsize-InputParameter.Read_length-r2_slen+1;
		}else{
			ref_read1 = sub_str.substr(insertsize-InputParameter.Read_length+r1_slen, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(0, InputParameter.Read_length-r2_slen);
			read1_pos = pos+insertsize-InputParameter.Read_length-r1_slen+1;		
			read2_pos = pos+1;		
		}
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(ref_read1) || !check_seq(ref_read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = ref_read1+ref_read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		string read1_order, read2_order;
		if ( InputParameter.Is_cyclization == 1 )
		{
			if(selection == 0){
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";
			}else{
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
			}

		}else if (InputParameter.Insertsize_mean>0)
		{
			if(selection == 0){
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
									
			}else{
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";				
			}
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		bool* Is_insertion_pos1;
		bool* Is_insertion_pos2;
		Is_insertion_pos1 = new bool[InputParameter.Read_length];
		Is_insertion_pos2 = new bool[InputParameter.Read_length];
		for(int i =0 ; i < InputParameter.Read_length; i++)
		{
			Is_insertion_pos1[i] = 0;
			Is_insertion_pos2[i] = 0;
		}	
		string read1=ref2read(ref_read1, indel1, Is_insertion_pos1);
		string read2=ref2read(ref_read2, indel2, Is_insertion_pos2);		
		
		
		string output_read1, output_read2, output_quality_seq1, output_quality_seq2;
		
		vector<int> error_pos1;
  	vector<char> raw_base1;
  	vector<int> error_pos2;
  	vector<char> raw_base2;
  		
		if(InputParameter.Q_Mode == 0)
		{
  		//simulate read1
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle = i;

  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(Is_insertion_pos1[i]){  //insertion not to simulate substitution error
  					call_base = ref_base;
  				}else{
  					Error_pos_distr[i+1]++;
  					error_pos1.push_back(i);
  					raw_base1.push_back(ref_base);
  				}
  			}
  			output_read1.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));
  		}
  		
  		//simulate read2
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			cycle = i+Simulate_Cycle_num/2;	
  			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num*Quality_num, num);
  			int call_base_num = int(location/Quality_num);
  			char call_base = Bases[call_base_num];
  			if(ref_base != call_base){
  				if(Is_insertion_pos2[i])
  				{
  					call_base=ref_base;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  					error_pos2.push_back(i);
  					raw_base2.push_back(ref_base);
  				}
  			}
  			output_read2.push_back(call_base);
  			int Qscore = location%Quality_num;
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));
  		}
  		
		}else{
  		//simulate read1
  		
  		int pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read1[i];
  			int cycle;
  			cycle = i;
  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == 0){
  				
  				location = search_location(First_cycle_matrix[alphabet2[ref_base]][0], Seq_Base_num*Quality_num, num);
			
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num -1 ;
  //					cerr<<"read1 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			
  			pre_Q = Qscore;
  			
  			if(ref_base != call_base){
  				if(Is_insertion_pos1[i]){
  					call_base = ref_base;
  				}else{
  					Error_pos_distr[i+1]++;
    				error_pos1.push_back(i);
    				raw_base1.push_back(ref_base);
  				}
  			}
  			output_read1.push_back(call_base);
  			
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq1.push_back(quality_value);
  			Q_to_Erate_distr[i+1]+= pow(10,double(Qscore)/double(-10));

  		}
  		
  		//simulate read2
  		pre_Q = 0;
  		for(int i = 0; i < InputParameter.Read_length; i++)
  		{
  			double num=double(rand())/double(RAND_MAX);
  			double num2=double(rand())/double(RAND_MAX);
  			char ref_base = read2[i];
  			int cycle;
  			cycle = i+Simulate_Cycle_num/2;

  			char call_base;
  			int Qscore;
  			int location = 0;
  			int location2 = 0;
  			if(cycle == Simulate_Cycle_num/2){

  				location = search_location(First_cycle_matrix[alphabet2[ref_base]][1], Seq_Base_num*Quality_num, num);
  //				if(location == 0){cerr<<"num:"<<num<<" cycle:"<<cycle<<" alphabet2[ref_base]:"<<(int)alphabet2[ref_base]<<endl;}
  				if(location == Seq_Base_num*Quality_num){
  					call_base = ref_base;
  					Qscore = Quality_num-1;
  //					cerr<<"read2 location == Seq_Base_num*Quality_num"<<endl;
    			} //
    			else{
    				int call_base_num = int(location/Quality_num);
    			  call_base = Bases[call_base_num];
    			  Qscore = location%Quality_num;
    			}
  				
  			}else{
  				int location = search_location(Simulation_matrix2[cycle][pre_Q], Quality_num, num);
  				
  				if(location == Quality_num){
  					Qscore = pre_Q;
    			} //
    			else{
    				Qscore = location;
    			}
    			//cerr<<"ref_base:"<<ref_base<<" cycle:"<<cycle<<" Qscore:"<<Qscore<<" Seq_Base_num:"<<Seq_Base_num<<" num2:"<<Seq_Base_num<<endl;
  				int location2 = search_location(Simulation_matrix1[alphabet2[ref_base]][cycle][Qscore], Seq_Base_num, num2);
  				if(location2 == Seq_Base_num){
  					call_base = ref_base;
    			} //
    			else{
    				call_base = Bases[location2];
    			}
  			}
  			pre_Q = Qscore;
  			if(ref_base != call_base){
  				if(Is_insertion_pos2[i]){
  					call_base = ref_base;
  				}else{
  					Error_pos_distr[i+1+InputParameter.Read_length]++;
  					error_pos2.push_back(i);
  					raw_base2.push_back(ref_base);
  				}
  			}
  			output_read2.push_back(call_base);
  
  			char quality_value = Qscore + InputParameter.Q_shift;  
  			output_quality_seq2.push_back(quality_value);
  			Q_to_Erate_distr[i+1+InputParameter.Read_length]+= pow(10,double(Qscore)/double(-10));

  		}
		}
		
		delete[] Is_insertion_pos1;
		delete[] Is_insertion_pos2;
		
		//output simulate reads
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
		//read1 information
		Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read1_order<<"\t"<<read1_pos<<"\t";
		for(int i = 0; i < error_pos1.size(); i++)
		{
			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
		}
		if(error_pos1.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel1.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-";
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read1.size();){
        //cout<<i<<"\t"<<k<<endl;
        if(indel1.count(k)==0){
           i++; k++; 
        }
        else if(indel1[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel1[k].size(); l++)
        	{
        		delet_inf += ref_read1[i+l];
        	}
        	delet_inf +=";";
//          	delet_inf += tem + "," + ref_read1[i] + ";";
          Read1_del_sum+=indel1[k].size();
          i+=indel1[k].size();k++;
          
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        		
        		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
            Read1_ins_sum+=indel1[k].size(); 
            k+=indel1[k].size();
           
        }
    	}
    	while(indel1.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
        Read1_ins_sum+=indel1[k].size();
        k+=indel1[k].size();
        
    	}
    	
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-";
    	}else{
    		Infor_outfile<<delet_inf;
    	}
  	}
  	Infor_outfile<<endl;
  	
  	//read2 information
		Infor_outfile<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read2_order<<"\t"<<read2_pos<<"\t";
		for(int i = 0; i < error_pos2.size(); i++)
		{
			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
		}
		if(error_pos2.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel2.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read2.size();){
        //cout<<i<<"\t"<<k<<endl;
        if(indel2.count(k)==0){
           i++; k++; 
        }
        else if(indel2[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel2[k].size(); l++)
        	{
        		delet_inf += ref_read2[i+l];
        	}
        	delet_inf +=";";
//          	delet_inf += tem + "," + ref_read1[i] + ";";
          Read2_del_sum+=indel2[k].size(); 
          i+=indel2[k].size();k++;      		
        	
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
          Read2_ins_sum+=indel2[k].size();
          k+=indel2[k].size();
            
        }
    	}
    	while(indel2.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
				Read2_ins_sum+=indel2[k].size();
        k+=indel2[k].size();
    	}
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-"<<endl;
    	}else{
    		Infor_outfile<<delet_inf<<endl;
    	}
  	}
  	
  	
  	//output reads
		if(!InputParameter.Output_type){
			//output read file1
			Outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Outfile1<<endl<<output_read1<<endl
  			<<"+"<<endl
  			<<output_quality_seq1<<endl;
  		
  		//output read file2
			Outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Outfile2<<endl<<output_read2<<endl
  			<<"+"<<endl
  			<<output_quality_seq2<<endl;
		}else{
			//*.gz output
			//output read file1
			Gz_outfile1<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Gz_outfile1<<endl<<output_read1<<endl
  			<<"+"<<endl
  			<<output_quality_seq1<<endl;
  		
  		//output read file2
			Gz_outfile2<<"@read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Gz_outfile2<<endl<<output_read2<<endl
  			<<"+"<<endl
  			<<output_quality_seq2<<endl;
		}
	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}


uint64_t simulate_fa_reads(string &seq,uint64_t seqlen, uint64_t rd_pair, string id_seq, int i_or_I, uint64_t reads_all)
{
	int whether_check_seq = 0; 
	if(!check_seq(seq)){
		whether_check_seq = 1;
	}
	
	uint64_t reads_count=0;
	cerr<<"Begin to output reads"<<endl;
	for(uint64_t pair_count=0; pair_count < rd_pair; pair_count++)
	{
		//simulate insertsize
		int insertsize = simulate_insertsize(InputParameter.Insertsize_mean,InputParameter.Insertsize_sd);
		if (insertsize<InputParameter.Read_length){pair_count--;continue;}
		if (seqlen<insertsize){return reads_count;}
		uint64_t N = 1000000000000;
		uint64_t pos = (uint64_t)(((uint64_t)((double)rand() / double(RAND_MAX) * N)) % seqlen);
		if (pos+insertsize>seqlen){pair_count--;continue;}
			
		//get insert seq
		string sub_str=seq.substr(pos,insertsize);
		
		map<int,string,less<int> > indel1;
		map<int,string,less<int> > indel2;
		int r1_slen = 0;
		int r2_slen = 0; 
		if(InputParameter.Is_simulate_InDel)
		{
			get_reads_indel(InputParameter.Read_length, indel1, indel2, r1_slen, r2_slen, InDel_max_len, InDel_error_matrix, InDel_num);
		}
		
		string ref_read1, ref_read2;
		int selection=int(rand()%2); //0 or 1, for selecting output file randomly and deciding read +/-
		
		int read1_pos, read2_pos;
		if(selection == 0)
		{
			ref_read1 = sub_str.substr(0, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(insertsize-InputParameter.Read_length+r2_slen, InputParameter.Read_length-r2_slen);
			read1_pos = pos+1;
			read2_pos = pos+insertsize-InputParameter.Read_length-r2_slen+1;
		}else{
			ref_read1 = sub_str.substr(insertsize-InputParameter.Read_length+r1_slen, InputParameter.Read_length-r1_slen);
			ref_read2 = sub_str.substr(0, InputParameter.Read_length-r2_slen);
			read1_pos = pos+insertsize-InputParameter.Read_length-r1_slen+1;		
			read2_pos = pos+1;		
		}
		
		//check whether contain 'N' or nonbase char
		if(whether_check_seq && (!check_seq(ref_read1) || !check_seq(ref_read2))){
			pair_count--;
			continue;
		}
		
		//simulate GC bias
		if(InputParameter.Is_simulate_GC_bias){
			string check_seq = ref_read1+ref_read2;
			if(simulate_GC_bias(check_seq,GC_bias_abundance)){pair_count--;continue;}
		}
		
		
		//insertsize statistics
		if(InsertSize_distr[insertsize]>0)
		{
			InsertSize_distr[insertsize]++;
		}else{
			InsertSize_distr[insertsize] = 1;
		}
		
		reads_count++;
		
		string read1_order, read2_order;
		if ( InputParameter.Is_cyclization == 1 )
		{
			if(selection == 0){
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";
			}else{
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
			}

		}else if (InputParameter.Insertsize_mean>0)
		{
			if(selection == 0){
				ref_read2=reversecomplementary(ref_read2);
				read1_order = "+";
				read2_order = "-";
									
			}else{
				ref_read1=reversecomplementary(ref_read1);
				read1_order = "-";
				read2_order = "+";				
			}
		}else{
			cout<<"Error:insertsize mean is smaller than 0"<<endl;
			exit(-1);
		}
		
		bool* Is_insertion_pos1;
		bool* Is_insertion_pos2;
		Is_insertion_pos1 = new bool[InputParameter.Read_length];
		Is_insertion_pos2 = new bool[InputParameter.Read_length];
		for(int i =0 ; i < InputParameter.Read_length; i++)
		{
			Is_insertion_pos1[i] = 0;
			Is_insertion_pos2[i] = 0;
		}	
		string read1=ref2read(ref_read1, indel1, Is_insertion_pos1);
		string read2=ref2read(ref_read2, indel2, Is_insertion_pos2);		
		
		string output_read1, output_read2;
		
		//simulate read1
		vector<int> error_pos1;
		vector<char> raw_base1;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read1[i];
			int cycle;
			cycle = i;
			
			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(Is_insertion_pos1[i])
				{
					call_base = ref_base;
				}else{
					Error_pos_distr[i+1]++;

					error_pos1.push_back(i);
					raw_base1.push_back(ref_base);
				}
			}
			output_read1.push_back(call_base);
		}
		
		//simulate read2
		vector<int> error_pos2;
		vector<char> raw_base2;
		for(int i = 0; i < InputParameter.Read_length; i++)
		{
			double num=double(rand())/double(RAND_MAX);
			char ref_base = read2[i];
			int cycle;
			cycle = i+Simulate_Cycle_num/2;

			int location = search_location(Simulation_matrix[alphabet2[ref_base]][cycle], Seq_Base_num, num);
			char call_base = Bases[location];
			if(ref_base != call_base){
				if(Is_insertion_pos2[i]){
					call_base = ref_base;
				}else{
					Error_pos_distr[i+1+InputParameter.Read_length]++;
					error_pos2.push_back(i);
					raw_base2.push_back(ref_base);
				}
			}
			output_read2.push_back(call_base);
		}
		
		delete[] Is_insertion_pos1;
		delete[] Is_insertion_pos2;		
		
		
		if (reads_count%10000==0)
		{
			cerr<<"Output "<<reads_count<<" pair reads"<<endl;
		}
		
		//read1 information
		Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read1_order<<"\t"<<read1_pos<<"\t";
		for(int i = 0; i < error_pos1.size(); i++)
		{
			Infor_outfile<<error_pos1[i]+1<<","<<raw_base1[i]<<"->"<< output_read1[error_pos1[i]] <<";";
		}
		if(error_pos1.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel1.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-";
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read1.size();){
        //cout<<i<<"\t"<<k<<endl;
        if(indel1.count(k)==0){
           i++; k++; 
        }
        else if(indel1[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel1[k].size(); l++)
        	{
        		delet_inf += ref_read1[i+l];
        	}
        	delet_inf +=";";
//          	delet_inf += tem + "," + ref_read1[i] + ";";
          Read1_del_sum+=indel1[k].size();
          i+=indel1[k].size();k++;
          
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        		
        		inser_inf += tem + "," + indel1[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
            Read1_ins_sum+=indel1[k].size(); 
            k+=indel1[k].size();
           
        }
    	}
    	while(indel1.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel1[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
        Read1_ins_sum+=indel1[k].size();
        k+=indel1[k].size();
        
    	}
    	
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-";
    	}else{
    		Infor_outfile<<delet_inf;
    	}
  	}
  	Infor_outfile<<endl;
  	
  	//read2 information
		Infor_outfile<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2<<"\t"<<insertsize<<"\t"<<i_or_I<<"\t"<<id_seq<<"\t"<<read2_order<<"\t"<<read2_pos<<"\t";
		for(int i = 0; i < error_pos2.size(); i++)
		{
			Infor_outfile<<error_pos2[i]+1<<","<<raw_base2[i]<<"->"<< output_read2[error_pos2[i]] <<";";
		}
		if(error_pos2.size() == 0){
			Infor_outfile<<"-";
		}
		Infor_outfile<<"\t";
		
		if(indel2.size() == 0){
			Infor_outfile<<"-"<<"\t"<<"-"<<endl;
		}else{
			string inser_inf;
			string delet_inf;
  		int k=0;
  		int j=0;
    	for(size_t i=0; i<ref_read2.size();){
        //cout<<i<<"\t"<<k<<endl;
        if(indel2.count(k)==0){
           i++; k++; 
        }
        else if(indel2[k][0]=='-'){
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	delet_inf += tem + ",";
        	for(int l=0; l<indel2[k].size(); l++)
        	{
        		delet_inf += ref_read2[i+l];
        	}
        	delet_inf +=";";
//          	delet_inf += tem + "," + ref_read1[i] + ";";
          Read2_del_sum+=indel2[k].size(); 
          i+=indel2[k].size();k++;      		
        	
        }
        else{
        	int num = k+1;
        	string tem = boost::lexical_cast<string>(num);
        	inser_inf += tem + "," + indel2[k] + ";";
//              Infor_outfile<<i+j<<","<<indel[k]<<";";
          Read2_ins_sum+=indel2[k].size();
          k+=indel2[k].size();
            
        }
    	}
    	while(indel2.count(k)>0){
        int num = k+1;
        string tem = boost::lexical_cast<string>(num);
        inser_inf += tem + "," + indel2[k] + ";";
//      		Infor_outfile<<i+j<<","<<indel[k]<<";";
				Read2_ins_sum+=indel2[k].size();
        k+=indel2[k].size();
    	}
    	if(inser_inf.empty()){
    		Infor_outfile<<"-"<<"\t";
    	}else{
    		Infor_outfile<<inser_inf<<"\t";
    	}
    	if(delet_inf.empty()){
    		Infor_outfile<<"-"<<endl;
    	}else{
    		Infor_outfile<<delet_inf<<endl;
    	}
  	}
  	
  	//output reads
		if(!InputParameter.Output_type){
			//output read file1
			Outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Outfile1<<endl<<output_read1<<endl;
  		
  		//output read file2
			Outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Outfile2<<endl<<output_read2<<endl;

		}else{
			//*.gz output
			//output read file1
			Gz_outfile1<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<1;
			Gz_outfile1<<endl<<output_read1<<endl;
  		
  		//output read file2
			Gz_outfile2<<">read_"<<InputParameter.Insertsize_mean<<"_"<<reads_count+reads_all<<"/"<<2;
			Gz_outfile2<<endl<<output_read2<<endl;
		}		
	}
	cerr<<"Finish output reads"<<endl;
	return reads_count;
}
